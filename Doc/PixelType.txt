Pixel Type of a DICOM image is a very complex task. esp in a templated code context.
For instance you need to take into account the following paramaters:

- Bits Allocated
- Bits Stored
- High Bit
- Pixel Representation

this type of information is still very low level. And if you except the 12bits data case, this is failry easy to deal with.
But you need to add on thop of that the notion of Intercept and slope.

Yes indeed DICOM does not specify how to store floating point values. Therefore the only way to do that is to store image as an integrer type (OB or OW), and then store the coeffiecient to applya  linear transofmr on your data.

  // 0028 1052 DS IMG Rescale Intercept
  // 0028 1053 DS IMG Rescale Slope

Thus the 'low level' pixel type is not enough you need now to know:
- Will you data be float ? or still int ?
- Will your data still be signed or unsigned ?
- what will be the final range of your data ?

This should be sumarized in the following pseudo code:
  int s = int(m_RescaleSlope);
  int i = int(m_RescaleIntercept);
  float fs = float(s);
  float fi = float(i);

  double slope_dif = fabs(fs - m_RescaleSlope);
  double inter_dif = fabs(fi - m_RescaleIntercept);
  if (slope_dif > 0.0 || inter_dif > 0.0)
    {
    if (m_ComponentType != ImageIOBase::DOUBLE)
      {
      this->SetComponentType(ImageIOBase::FLOAT);
      }
    }

  // If the intercept is negative, unsigned integral values need to be
  // changed to signed integral values. Otherwise, the rescale intercept
  // code will overflow.

  if (m_RescaleIntercept < 0)
    {
    switch (m_ComponentType)
      {
      case ImageIOBase::UCHAR:
        m_ComponentType = ImageIOBase::CHAR;
        break;
      case ImageIOBase::UINT:
        m_ComponentType = ImageIOBase::INT;
        break;
      case ImageIOBase::USHORT:
        m_ComponentType = ImageIOBase::SHORT;
        break;
      case ImageIOBase::ULONG:
        m_ComponentType = ImageIOBase::LONG;
        break;
      default:
        break;
      }
    }

