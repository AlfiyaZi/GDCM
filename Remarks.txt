// Store here all the remarks (by mail, or other)

From Mathieu, 30/11/2005
------------------------
    Etat actuel:

- J'ai ecris les classes minimum qui permettent de parser tout les fichiers 
DICOM de gdcmData (avec les fameux 13 devient 10, 6 devient 4 (1)...). 
Je suis relativement satisfait des premier resultats.
Je peux donc confirmer que des operations de seekg/read (<0xfff) 
sont extrement rapide.

- Dans le design actuel je fais tout pour eviter le 'New'. 
Je continue a penser que ca ne vaut la peine que pour les grosses structures, 
et pour moi ca devrait etre meme eviter si on choisit un design ala libtiff 
(cf custom tag et autre).
- Je n'utilise pas du tout le dictionaire lors du parsing (yes!), 
je suis donc capable -apparement- de lire les fichiers DICOM implicit 
avec leurs sequences.
- Je n'ai pas fais de structure particuliere pour les fragments JPEG, RLE: 
c'est des bete sequences !
- Beaucoup de template, on ne peut plus se tirer une balle dans le pied 
au niveau de la compilation !

    Futur:

- Mon parser n'authorise pas de sauter les sequences (explicit length) pour 
l'instant (ni les shadow groupe).
- Je n'ai pas de ProgressReport (pour l'instant)

- Je tiens a garder le parser completement a part du reste du source code, 
pour permettre a un utilisateur de compiler uniquement la partie parser.
- Accentuer la notion de groupe. On doit pouvoir lire/ecrire un groupe 
a la fois. 
Sauter (seekg) un groupe, (et constuire un index si les groupes n'indique pas 
la length du groupe??).
- Separation des documents ACR, des documents DICOM V3, c'est pas du tout 
le meme dictionaire, et pas du tout la meme structure 
(il suffit de lire qlq byte d'un fichier pour identifier l'un de l'autre de 
toute facon).
- Je veux plus clairement indiquer que Document DICOM c'est un meta header 
(element explicit) et ensuite un ensemble de groupes qui sont (exclusivement) 
soit Implicit soit Explicit.

Dans l'archi future que je vois:
- Un parser: indique si le document est lisible ou pas 
(indique ACR-NEMA, Explicit, Big Endian...)
- Un InformationReader, indique le type de Document: DICOMDIR, Image, Waveform,
 PDF...
- Un DataReader qui se sous-classe en RLEReader / JPEGReader 
(avec support du streaming: je veux pouvoir lire un sous volume 
de mon image 4Go...)

Une fois que ces 'helper' seront valides, alors on pourra penser a une classe 
super user friendly qui encapsule tout ca :)

Mathieu
(1) Pour l'instant gdcm2 saute (seekg) les sequences big/little endian, 
des qu'elle se rend compte qu'un truc va pas. 
Je differe ce bug en esperant qu'il n'impacte pas le design actuel...

Ps: j'adore les templates !


From JPR :
--------

>
>> - Quelle que soit la maniere dont on s'y prendra pour acceder aux pixels, 
>>il faudra que ca soit suffisament général (generique?) pour que l'on puisse 
>>acceder *également* aux pixels dans une icone (publique ou privée, avec 
>>ou sans LUT, etc), et/ou aux pixels qui peuvent etre stockés dans le DicomDir,
>> au niveau de l'IMAGE ou au niveau de la SERIE (au moins)
>
>
> Ca serait genial !
>
>> - SerieHelper :
>> -- on n'echappera pas au fait de devoir laisser a l'utilisateur nous passer 
>>une fonction qu'il a ecrite lui même, sous sa responsabilité, et qui lui 
>>permet de comparer des entetes d'images, pour nous dire comment *il* veut 
>>qu'on les ventille (meme SerieUID n'est pas suffisant)
>> -- Il faudra qu'il puisse nous passer *sa* fonction de comparaison de tri, 
>>et le sens (ascendant / descendant)
>> C'est fait dans gdcm1.2 (a la C : l'utilisateur nous passe un pointeur sur 
>>sa fonction. Ca marche.
>> Pour swigger ca en Python c'est autre chose ...)
>
>
> Je continue a penser que l'histoire des operateurs et restrictions est plutot
> bonne. Je me souvient des inconvenients. Qulqun pour me rafraichie la memoire.


Les operateurs de restrictions servent a l'utilisateur a dire au SerieHelper 
quelles images il veut garder/ignorer 
(ex : PatientName ==  Douek, + Modalite == CT ou MR)
Ca marche bien , c'est wrapable.
Une fois connues les images sur lesquelles l'utilisateur veut travailler, 
c'est la que ca se gate.
SerieHelper 'ventillait' les images en autant de 'CoherentFileList' qu'il y 
avait de SerieUID.
Bonne idée en apparence, car, dans une meme SerieUID, il peut y avoir, 
par exemple, plusieurs series spatio-temporelles 
(n niveaux de coupe, a p instants), et si on donne une telle liste de fichiers 
a VTK, ca va lui faire tout drole.
J'ai renommé CoherentFileList en SingleUIDFileSet, plus parlant

D'autre part, des fichiers constituant une 'unité logique' peuvent se trouver 
avec des SeriesUID différent (exemple : 50 series differentes, correspondant 
a 50 instants differents, contenant chacune 5 images, correspondants 
a 5 niveaux de coupes : l'unité logique de travail pour l'utilisateur est le 
'niveau de coupe, aux 50 instants, pas 50 volumes !)
Il met ses gdcm::File* dans un vecteur, et demande de le splitter en autant 
de XCoherentFileSets qu'il y a de niveaux de coupes.
En standard, il y a :   
  XCoherentFileSetmap SplitOnOrientation(FileList *fileSet);
  XCoherentFileSetmap SplitOnPosition(FileList *fileSet);
  XCoherentFileSetmap SplitOnTagValue(FileList *fileSet,  uint16_t group, uint16_t elem);
j'ai introduit la notion de XCoherentFileSet., (X pour Extra, et ne pas 
collisioner avec l'ancien nom ...)
J'imagine qu'un jour, le split ne devra pas se faire seulement sur *un* champs,
 mais sur une combinaisons de champs, avec des comparaisons dont seul 
 l'utilisateur aura le secret!
Pas de pb s'il nous passe un pointeur sur *sa* fonction de comparaison!
(Pas de honte a passer un pointeur sur une fonction : c'est bien comme ca que 
fait la STL; Python va faire la gueule ...)

> Pour rappel, on a access a la VM et la VR. Je pense q'il est donc facile 
>d'ecrire une classe qui fasse les operations plus grand que, plus petit que, 
>dans un interval, ==, != ...
> Apres oui le probleme est comment proposer un bon comportement par defaut. Je ne suis pas sur que l'on arrive a qlqchose pour tous les gouts, mais si on propose un moyen de rafiner le resultat, je pense que tout le monde devrait etre content.


On ne pourra *surement* pas contenter tout le monde a tous les coups, 
par defaut.
La maniere decrite + haut permet a l'utilisateur de nous dire tres exactement 
ce qu'il attend que SerieHelper fasse.

>
>
>> -- Il faudra qu'on puisse dire au SerieHelper qu'il doit travailler sur tout ou partie d'un DicomDir ( gdcm::DicomDirSerie contient actuellement une std::list de pointeurs sur DicomDirImage; chacun de ces DicomDirImage contient tout ce qu'il faut pour etre comparé a un autre, avec les memes fonctions de dans SerieHelper.
>> Le pb, dans la config actuelle, on ne peut pas reutiliser tout ca.
>

>> - DicomDir :
>> Le temps de parsing d'un DicomDir est d'un lenteur *tout a fait*anormale.
>> C'est que notre maniere de proceder n'est peut-etre pas la bonne 
>>(construire un gdcm::Docoment + recopier les SQitems en tant que 
>>DicomDirObjets


>> - ReaderVTK :
>> l'utilisateur doit pouvoir nous dire s'il veut faire un mirror ou un 
>>upsidedown sur ses images avant de creer un volume (ca evitera qu'il voit 
>>son patient a l'envers)
>> C'est fait aussi, probablement a la goret.
>> Si on peut integrer ca dans nos reflexions, ca ne serait pas mal.
>
>
> Pas facile.


--> Seul l'utilisateur sait ce qu'il veut faire (voir pb de Luca Picello, 
et les discussions qui ont suivi).
Il passe au VTKReader la fonction qu'il veut qu'on appelle tout de suite apres 
que gdcm ai ammene les pixels en memoire, avant de les passer a VTK.
- Ca marche -en C++, pas en Python

>
>> - Les bricolages que nous appretions a faire pour diminuer le temps de 
>>lecture de l'entete n'auront plus lieu d'etre si on part sur des bases saines 
>>(gdcm2),
>> si les fruits tiennent la promesse des fleurs ( gdcm2 parse 150 fichiers
>>en 2 fois moins de temps qu'il ne faut a gdcm1 pour en Print une seule : 
>>ca met l'eau a la bouche , non?
>
>
>> - Je ne suis pas tres sur que les utilisateurs de Python de gdcm ont 
>>*par nature*, des besoins tres inferieurs a ceux des utilisateurs C++ de gdcm.
>> Il faudrait, a mon avis, que ce qu'on fait soit utilisable sans restriction 
>>en Python.
>> (S'il y a des methodes qui ne servent a rien on peut de pas les wrapper ...
>> La vraie question sera : si elles ne servent a rien, pourquoi sont-elles 
>>publiques ?
>
>
>
> Encore une fois je suis un peu leger sur le sujet. Est-ce que quelqu'un peut 
> me dire quel sont les besoins des utilisateurs python ?
> Pour moi ils veulent lire, ordonner, et ecrire des fichier DICOM.


En effet.
Et pour les selectionner/ordonner/etc  proprement, on a besoin de passer un 
pointeur sur fonction, a divers endroits.
Benoit a une idee de CallbackFunction (deja mise en oeuvre pour la progress bar,
dans la version cvs de gdcm)
Je vais essayer de faire ca pour les divers passages de fonctions qui sont 
deja dans gdcm (a part Luca, personne ne doir s'en servir ...)

JP

>
> Moi je suis souvent bloquer sur des trucs facile:
> - Lire un fichier DICOM et ecrire le flux jpeg (ca devrait etre facile non ?),
> - Lire un fichier JPEG et constuire les fragments jpeg qui vont bien,
> - Lire un fichier PDF et ecrire un fichier DICOM (allez, juste pour faire 
>   le malin!)...


PDF ?
P'tit joueur!
Prends un fichier wav (c'est pas une blague, ca existe : 
                       pour encapsuler un compte rendu oral)
;-)
JP

> Ca va au dela de la simple lecture/ecriture, je veux un access bas niveau, 
>qui a mon avis n'a pas besoin d'etre visible sur la couche python


From Benoit :
-----------

Pour les utilisateurs Python :
TOUT ce qu'il est possible de faire en C++, sans AUCUNE restriction !!!

- lire/ecrire tout document Dicom (Image, DicomDir, etc.)
- Creer une image from scratch
- Acceder/Modifier les pixels, la lut, les informations de l'image
- Acceder/Modifier tout entry Dicom

- Pouvoir spécifier/Modifier/etc. son propre dictionnaire et l'utiliser 
  pour les document Dicom
- Et tout ce que j'ai oublié de mettre 


From JPR
---------

Profitant de ce qu'on repart sur des bases saines, il faudrait qu'on colle 
rigoureusement a la terminologie Dicomn afin d'eviter des ambiguités 
conceptuelles

voir  : 04_05pu-1.pdf (page 14 ...)

Ci apres, le nom 'Documentation Dicom' + nom GDCM2 actuel

DATA ELEMENT        gdcm::DataElement
                                         
DATA ELEMENT TAG    gdcm::Tag

DATA SET            gdcm::DataSet
                    Ensemble de Data Elements
Jusque la, c'est super !

ITEM            A component of the value of a Data Element that is of 
                Value Representation Sequence of Items.
                An Item contains a Data Set .
                C'est ce qu'on appelait 'gdcm::SQItem' en gdcm1

NESTED DATA SET  a Data Set contained within a Data Element 
                 of an other Data Set.
                 May be nested recursively.
                 Only Data Elements with VR = SQ  may, themselves, 
                 contain Data Sets

                La formulation est lourde, mais ca veut dire qu'un DataSet 
                peut contenir des elements VR=SQ, qui contiendront des Data Sets
                Rien de nouveau, si ce n'est qu'il y a 2 noms.

ITEM DELIMITATION DATA ELEMENT   
             Used to mark the end of an Item of Undefined Length 
             in a Sequence of Items.
             This is the last Data Element in an Item of Undefined Length
             decrit dans le dicomV3.dic comme :
             fffe e00d UL 1 Item Delimitation Item"
                   
??? PAS DE NOM ???:                      
              le premier DataElement d'un Item  
              (value : 0xFFFFFFFF pour les Items of Undefined Length)
              (je le nommais 'ItemStarter' dans les commentaires)    
               decrit dans le dicomV3.dic comme :
              "fffe e000 UL 1 Item"

SEQUENCE DELIMITATION ITEM 
               marque la fin d'un Item of Undefined Length (value 0x00000000)
               decrit comme
              "fffe e0dd UL 1 Sequence Delimitation Item" (ca tombe bien)
               n'existe pas dans les 'Items of Defined Length'

SEQUENCE OF ITEMS (value representation : SQ)
              a Value Representation for Data Elements that contains a sequence
              of Data Sets.
              Sequence of Item allows for Nested Data Sets
              C'est ce qu'on appelait une 'gdcm::SeqEntry' en gdcm1.


Tout ca pour dire qu'on devrait réutiliser ces noms, autant que possible, 
pour eviter que le lecteur ne se perde (trop)

En particulier, pour le moment (GDCM2)

gdcm::SequenceItem contient un gdcm::DataSet.
On peut don considerer qu'il s'agit d'un ITEM.
mais, vu qu'il herite de gdcm::DataElement, ca serait plutot une 
SEQUENCE OF ITEMS. ?!?

le gdcm::FileSequence ne contient que l'offset de debut et l'offset de fin de ?
          ITEM ou SEQUENCE OF ITEMS  ?

Yé souis perdou!

D'autre part si on regarde le resultat de TestAllPrint 
pour gdcmData/gdcm-MR-PHILIPS-16-Multi-Seq.dcm,
on voit 350 lignes affichées, alors qu'il y en a 2500 avec PrintFile.
Ce qui me fait dire qu'il doit y avoir un pb profond qq part.

Il va *forcement* falloir qu'on retrouve les concepts de gdcm::SeqEntry 
et de gdcm::SQItem pour modeliser la realité ...



Another very important task is the partial reading often you only want to read a particular group, or a subset of tags. GDCM should allow a user to only read one group, or a subset of tags, and then stop reading.


What is the difference between Transfer Syntax and SOP Class ??

About RescaleSlope/RescaleIntercept:
This should ideally go into the gdcm library, since GE manage to produce PET image where Slope/Intercept is different from one slice to the other (yes no float image in DICOM only int type + rescale). Therefore it become very tricky to tell user what his *final* pixel type should be. In gdcm1.x we would only indicate user only the *stored* pixel type but never the output pixel type, so ITK-type application (anything templated) had to provide a helper class to find out what the real Pixel type should be (you can have almost all combination like: unsigned char becoming signed short ...)


Implementation detail:
At first I designed all DICOM object (ExplicitDataElement, ImplicitDataElement, Item, SequencesOfItems) to be able to read themself. But this does not make sense since you need a file level information: like TransferSyntax to be able to read / interpret properly.
This can be worked around by not reading directly in an ostream but a DICOMOstream which would have a proper state saying wheterh or not it shold be read as big endian or not. And actually this argument is stupid...
Another thing that I was trying to do is a proper printing of element as we PARSE the document. I think this is stupid to first load the dataset and THEN print it. A nice design should allow one to pass a function when starting to read an element and a function when ending reading an element. therefore the start function will increment the indent level, and then print the element (of whaterver user specify) and then the endMethod should decrement the indent level.
This allow me to keep my current design where you don't have the control when reading a SQ element, once you enter to read this element (explicit or Implicit) the function only returns when the SQ is fully read/skip/whatever
